function neighbourGrid = getNeighbourGrid(doaGrid, gridIndex)
%GETNEIGHBOURGRID Return neighboring angle or lat/lon values in grid.
% For a specified grid point, returns its immediate neighbors in the grid.
%
%Syntax:
%   neighbourGrid = getNeighbourGrid(doaGrid, gridIndex)
%
%Inputs:
%   doaGrid    - DOA grid structure (as generated by genDoaGrid) with fields:
%               - type       : 'angle' or 'latlon'
%               - dimension  : 1 or 2
%               - resolution : scalar or 2-element vector
%               - angleGrid  : 1×N (1D local) or 2×N (2D local/ground angles)
%               - latlonGrid : 2×N (ground only)
%
%   gridIndex  - Linear index of grid point (1-based, scalar)
%
%Output:
%   neighbourGrid -
%     - 1D: 1×2 vector, [lower, upper] neighboring values (angles)
%     - 2D: 2×2 matrix, where:
%           neighbourGrid(1,1): left  (lower azimuth/lat)
%           neighbourGrid(1,2): right (higher azimuth/lat)
%           neighbourGrid(2,1): up    (lower elevation/lon)
%           neighbourGrid(2,2): down  (higher elevation/lon)
%     Units follow grid type:
%       - For 'angle': [azimuth; elevation] in radians
%       - For 'latlon': [latitude; longitude] in degrees
%
%Notes:
%   - Neighboring points use boundary clipping (no wrapping).
%   - Grid is stored column-wise (MATLAB convention).
%   - For 2D: index ordering follows meshgrid (el, az) or (lat, lon).
%
%Example:
%   ngb = getNeighbourGrid(doaGrid, 10);  % Returns neighbors of grid point 10
%
%See also: ind2sub, sub2ind

arguments
  doaGrid (1,1) struct
  gridIndex (1,1) {mustBePositive, mustBeInteger}
end

% -------------------------------------------------------------------------
% Required field checks
% -------------------------------------------------------------------------
if ~isfield(doaGrid, 'dimension') || isempty(doaGrid.dimension)
  error('getNeighbourGrid:MissingProperty', ...
    'doaGrid.dimension is required.');
end
if ~isfield(doaGrid, 'resolution') || isempty(doaGrid.resolution)
  error('getNeighbourGrid:MissingProperty', ...
    'doaGrid.resolution is required.');
end
if ~isfield(doaGrid, 'type') || isempty(doaGrid.type)
  error('getNeighbourGrid:MissingProperty', ...
    'doaGrid.type is required.');
end

switch doaGrid.dimension
  case 1
    if ~isfield(doaGrid, 'angleGrid') || isempty(doaGrid.angleGrid)
      error('getNeighbourGrid:MissingProperty', ...
        'doaGrid.angleGrid is required for 1D neighbor query.');
    end
    if ~isscalar(doaGrid.resolution)
      error('getNeighbourGrid:InvalidResolution', ...
        'doaGrid.resolution must be scalar for 1D grid.');
    end

    if gridIndex < 1 || gridIndex > doaGrid.resolution
      error('getNeighbourGrid:InvalidGridIndex', 'gridIndex out of range.');
    end

    lowerIdx = max(gridIndex - 1, 1);
    upperIdx = min(gridIndex + 1, doaGrid.resolution);

    % 1D output: [lower, upper]
    neighbourGrid = [doaGrid.angleGrid(lowerIdx), doaGrid.angleGrid(upperIdx)];

  case 2
    % Parse total points and grid resolution
    if isscalar(doaGrid.resolution)
      Naz = doaGrid.resolution;
      Nel = doaGrid.resolution;
    else
      Naz = doaGrid.resolution(1);
      Nel = doaGrid.resolution(2);
    end
    totalPoints = Naz * Nel;
    gridResolution = [Nel, Naz];

    if gridIndex < 1 || gridIndex > totalPoints
      error('getNeighbourGrid:InvalidGridIndex', 'gridIndex out of range.');
    end

    % Index ordering follows meshgrid storage:
    %   gridResolution = [N_row, N_col]
    %   ind2sub -> (rowIdx, colIdx)
    [rowIdx, colIdx] = ind2sub(gridResolution, gridIndex);

    % Boundary-clipped neighbor positions
    rowUp    = max(rowIdx - 1, 1);                   % up    (lower el/lon)
    rowDown  = min(rowIdx + 1, gridResolution(1));   % down  (higher el/lon)
    colLeft  = max(colIdx - 1, 1);                   % left  (lower az/lat)
    colRight = min(colIdx + 1, gridResolution(2));   % right (higher az/lat)

    idxUp    = sub2ind(gridResolution, rowUp,   colIdx);
    idxDown  = sub2ind(gridResolution, rowDown, colIdx);
    idxLeft  = sub2ind(gridResolution, rowIdx,  colLeft);
    idxRight = sub2ind(gridResolution, rowIdx,  colRight);

    switch doaGrid.type
      % ---------------------------------------------------------------
      case 'angle'
        if ~isfield(doaGrid, 'angleGrid') || isempty(doaGrid.angleGrid)
          error('getNeighbourGrid:MissingProperty', ...
            'doaGrid.angleGrid is required for local 2D neighbor query.');
        end

        % [az_left, az_right; el_up, el_down] (radians)
        neighbourGrid = zeros(2,2);
        neighbourGrid(1,1) = doaGrid.angleGrid(1, idxLeft);   % azimuth left
        neighbourGrid(1,2) = doaGrid.angleGrid(1, idxRight);  % azimuth right
        neighbourGrid(2,1) = doaGrid.angleGrid(2, idxUp);     % elevation up
        neighbourGrid(2,2) = doaGrid.angleGrid(2, idxDown);   % elevation down

      % ---------------------------------------------------------------
      case 'latlon'
        if ~isfield(doaGrid, 'latlonGrid') || isempty(doaGrid.latlonGrid)
          error('getNeighbourGrid:MissingProperty', ...
            'doaGrid.latlonGrid is required for ground 2D neighbor query.');
        end

        % [lat_left, lat_right; lon_up, lon_down] (degrees)
        neighbourGrid = zeros(2,2);
        neighbourGrid(1,1) = doaGrid.latlonGrid(1, idxLeft);   % latitude left
        neighbourGrid(1,2) = doaGrid.latlonGrid(1, idxRight);  % latitude right
        neighbourGrid(2,1) = doaGrid.latlonGrid(2, idxUp);     % longitude up
        neighbourGrid(2,2) = doaGrid.latlonGrid(2, idxDown);   % longitude down

      otherwise
        error('getNeighbourGrid:InvalidType', ...
          'doaGrid.type must be ''angle'' or ''latlon''.');
    end
end % switch
end % function
